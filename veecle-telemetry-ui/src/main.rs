//! `veecle-telemetry-ui` is a visualizer for traces generated by Veecle OS applications.
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // hide console window on Windows in release

#[cfg(not(target_arch = "wasm32"))]
use std::io::BufRead;
#[cfg(not(target_arch = "wasm32"))]
use std::io::IsTerminal;
#[cfg(not(target_arch = "wasm32"))]
use std::path::PathBuf;
#[cfg(not(target_arch = "wasm32"))]
use std::sync::mpsc;
#[cfg(not(target_arch = "wasm32"))]
use std::{io, thread};

#[cfg(not(target_arch = "wasm32"))]
use anyhow::Context;
#[cfg(not(target_arch = "wasm32"))]
use clap::Parser;

use veecle_telemetry_ui::app::{StartupOptions, VeecleTelemetryApp};
#[cfg(not(target_arch = "wasm32"))]
use veecle_telemetry_ui::connection::Connection;
#[cfg(not(target_arch = "wasm32"))]
use veecle_telemetry_ui::connection::file::FileConnection;
#[cfg(not(target_arch = "wasm32"))]
use veecle_telemetry_ui::connection::pipe::PipeConnection;
#[cfg(not(target_arch = "wasm32"))]
use veecle_telemetry_ui::connection::websocket::WebSocketConnection;

/// CLI argument helper for parsing the various initial connection specifications.
#[cfg(not(target_arch = "wasm32"))]
#[derive(Debug, Clone)]
enum InitialConnection {
    /// Equivalent to `File("./spans.jsonl")` but with the extra behavior of silently ignoring a
    /// missing file instead of returning an error.
    Default,
    File(PathBuf),
    WebSocket(String),
}

#[cfg(not(target_arch = "wasm32"))]
impl InitialConnection {
    /// Creates a connection from this initial connection specification.
    pub fn create_connection(
        &self,
        egui_ctx: egui::Context,
    ) -> anyhow::Result<Option<Box<dyn Connection>>> {
        match self {
            InitialConnection::Default => {
                match FileConnection::new_boxed("./spans.jsonl".to_owned()) {
                    Ok(connection) => Ok(Some(connection)),
                    Err(error)
                        if error
                            .root_cause()
                            .downcast_ref::<std::io::Error>()
                            .is_some_and(|error| error.kind() == std::io::ErrorKind::NotFound) =>
                    {
                        Ok(None)
                    }
                    Err(error) => Err(error),
                }
            }
            InitialConnection::File(path) => {
                let path = path.to_str().context("non-utf8 filename")?.to_owned();
                FileConnection::new_boxed(path).map(Some)
            }
            InitialConnection::WebSocket(url) => {
                WebSocketConnection::new_boxed(url.clone(), egui_ctx).map(Some)
            }
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl std::fmt::Display for InitialConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            InitialConnection::Default => {
                write!(f, "./spans.jsonl")?;
            }
            InitialConnection::File(path) => {
                write!(f, "{}", path.display())?;
            }
            InitialConnection::WebSocket(url) => {
                write!(f, "{url}")?;
            }
        }
        Ok(())
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl std::str::FromStr for InitialConnection {
    type Err = std::convert::Infallible;

    fn from_str(string: &str) -> Result<Self, Self::Err> {
        if string == "./spans.jsonl" {
            // This really shouldn't parse to `Default`, but clap re-parses the specified default
            // value so we can't easily have special behavior without it.
            Ok(InitialConnection::Default)
        } else if string.starts_with("ws://") || string.starts_with("wss://") {
            Ok(InitialConnection::WebSocket(string.to_owned()))
        } else {
            Ok(InitialConnection::File(PathBuf::from(string)))
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[derive(Parser, Debug)]
#[command(version, about)]
struct Cli {
    #[arg(
        default_value_t = InitialConnection::Default,
        help = "Data source to load traces from. Supports file paths (./spans.jsonl) or WebSocket URLs (ws://localhost:9000). If data is piped via stdin, this argument is ignored."
    )]
    source: InitialConnection,
}

/// Spawns a separate thread to handle stdin without blocking.
#[cfg(not(target_arch = "wasm32"))]
fn spawn_stdin_channel(ctx: egui::Context) -> mpsc::Receiver<String> {
    let (tx, rx) = mpsc::channel::<String>();
    thread::spawn(move || {
        for line in io::stdin().lock().lines() {
            let line = line.unwrap();

            if line.is_empty() {
                continue;
            }

            if tx.send(line).is_err() {
                break;
            }
            ctx.request_repaint();
        }
    });
    rx
}

#[cfg(not(target_arch = "wasm32"))]
fn main() -> eframe::Result<()> {
    let args = Cli::parse();

    re_log::setup_logging();

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([800.0, 600.0])
            .with_drag_and_drop(true),
        ..Default::default()
    };
    eframe::run_native(
        "veecle-telemetry-ui",
        options,
        Box::new(|cc| {
            let connection: Option<Box<dyn Connection>> = if !io::stdin().is_terminal() {
                // assuming we're getting data piped in
                Some(PipeConnection::new_boxed(spawn_stdin_channel(
                    cc.egui_ctx.clone(),
                )))
            } else {
                args.source.create_connection(cc.egui_ctx.clone())?
            };

            Ok(Box::new(VeecleTelemetryApp::new(
                cc,
                StartupOptions {
                    connection,
                    ..Default::default()
                },
            )))
        }),
    )
}

#[cfg(target_arch = "wasm32")]
fn main() {
    re_log::setup_logging();

    wasm_bindgen_futures::spawn_local(async {
        use eframe::wasm_bindgen::JsCast as _;

        let document = web_sys::window()
            .expect("No window")
            .document()
            .expect("No document");

        let canvas = document
            .get_element_by_id("app_canvas")
            .expect("Failed to find app_canvas")
            .dyn_into::<web_sys::HtmlCanvasElement>()
            .expect("app_canvas was not a HtmlCanvasElement");

        let web_options = eframe::WebOptions::default();

        let start_result = eframe::WebRunner::new()
            .start(
                canvas,
                web_options,
                Box::new(|cc| {
                    Ok(Box::new(VeecleTelemetryApp::new(
                        cc,
                        StartupOptions::default(),
                    )))
                }),
            )
            .await;

        // Remove the loading text and spinner:
        if let Some(loading_text) = document.get_element_by_id("loading_text") {
            match start_result {
                Ok(_) => {
                    loading_text.remove();
                }
                Err(e) => {
                    loading_text.set_inner_html(
                        "<p> The app has crashed. See the developer console for details. </p>",
                    );
                    panic!("Failed to start eframe: {e:?}");
                }
            }
        }
    });
}
