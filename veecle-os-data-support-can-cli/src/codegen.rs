//! The CAN code generator command implementation.

use std::fmt::Display;
use std::marker::PhantomData;
use std::str::FromStr;

use patharg::{InputArg, OutputArg};
use veecle_os_data_support_can_codegen::Generator;

/// We can't use `syn` types directly in a `clap::Parser` because they're not thread-safe, this pre-checks that it
/// parses but then just stores it as a string to re-parse later when used.
#[derive(Debug, Clone)]
struct Syn<T>(String, PhantomData<fn() -> T>)
where
    T: syn::parse::Parse;

impl<T> Syn<T>
where
    T: syn::parse::Parse,
{
    fn parse(&self) -> T {
        syn::parse_str(&self.0).expect("it was already checked on construction")
    }
}

impl<T> std::str::FromStr for Syn<T>
where
    T: syn::parse::Parse,
{
    type Err = syn::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        syn::parse_str::<T>(s)?;
        Ok(Self(s.to_owned(), PhantomData))
    }
}

/// Generates a wrapper around [`Syn`] with the given name and the given default value.
///
/// A type generated by this macro implements the [`Default`] trait, which can be latter used by clap through the
/// `default_value_t` argument. This ensures the default value of the type is the one used by clap, avoiding duplication
/// and mismatches between the CLI and the library.
macro_rules! syn_path_with_default {
    ($type_name:ident, $default_value:tt) => {
        #[doc = "A Rust path to "]
        #[doc = stringify!($default_value)]
        #[doc = "."]
        #[derive(Debug, Clone)]
        pub struct $type_name(Syn<syn::Path>);

        impl Default for $type_name {
            fn default() -> Self {
                Self::from_str($default_value).expect("default value should not fail")
            }
        }

        impl FromStr for $type_name {
            type Err = syn::Error;

            fn from_str(s: &str) -> Result<Self, Self::Err> {
                Syn::from_str(s).map(Self)
            }
        }

        impl Display for $type_name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}", self.0.0)
            }
        }

        impl $type_name {
            fn into_inner(self) -> Syn<syn::Path> {
                self.0
            }
        }
    };
}

/// Cfg-gate to apply to the `arbitrary` code.
#[derive(Debug, Clone)]
pub struct ArbitraryCfg(Syn<syn::Meta>);

impl FromStr for ArbitraryCfg {
    type Err = syn::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Syn::from_str(s).map(Self)
    }
}

syn_path_with_default!(ArbitraryPath, "arbitrary");

/// Arbitrary configuration.
#[derive(clap::Args, Debug, Default)]
#[non_exhaustive]
pub struct ArbitraryOptionsArguments {
    /// Enable generating `arbitrary` integration code.
    #[arg(long = "arbitrary")]
    pub enabled: bool,

    /// Path to the `arbitrary` crate that should be used in the generated code.
    #[arg(long = "arbitrary-path", default_value_t)]
    pub path: ArbitraryPath,

    /// Cfg-gate to apply to the `arbitrary` code, defaults to ungated.
    #[arg(long = "arbitrary-cfg")]
    pub cfg: Option<ArbitraryCfg>,
}

syn_path_with_default!(VeecleOsRuntime, "veecle_os_runtime");
syn_path_with_default!(VeecleOsDataSupportCan, "veecle_os_data_support_can");
syn_path_with_default!(Serde, "serde");

/// Optional configurations.
#[derive(clap::Args, Debug, Default)]
#[non_exhaustive]
pub struct OptionsArguments {
    /// Path to the `veecle-os-runtime` crate that should be used in the generated code.
    #[arg(long, default_value_t)]
    pub veecle_os_runtime: VeecleOsRuntime,

    /// Path to the `veecle-os-data-support-can` crate that should be used in the generated code.
    #[arg(long, default_value_t)]
    pub veecle_os_data_support_can: VeecleOsDataSupportCan,

    /// Enable calling a frame validation function on each message type during deserialization. This should be an
    /// inherent method added onto the generated code:
    ///
    /// ```rust,ignore
    /// impl generated::SomeMessage {
    ///     pub(crate) fn validate_frame(frame: &veecle_os_data_support_can::Frame) -> Result<(), veecle_os_data_support_can::Error> {
    ///         ...
    ///     }
    /// }
    /// ```
    #[arg(long)]
    pub validate_message_frames: bool,

    /// Arbitrary configurations.
    #[command(flatten)]
    pub arbitrary: ArbitraryOptionsArguments,

    /// Path to the `serde` crate that should be used in the generated code.
    #[arg(long, default_value_t)]
    pub serde: Serde,
}

/// Arguments for the `codegen` command.
///
/// It is ensured that the default values given by the CLI and the ones given by the constructor are the same.
/// Executing the `codegen` command with `--veecle_os_runtime path::to:command` is equivalent to the following code:
///
/// ```rust
/// use std::str::FromStr;
///
/// use veecle_os_data_support_can_cli::codegen::{Arguments, VeecleOsRuntime, OptionsArguments};
///
/// let mut options = OptionsArguments::default();
/// options.veecle_os_runtime =
///     VeecleOsRuntime::from_str("path::to::veecle_os_runtime").expect("string to be a Rust path");
///
/// Arguments::new("path/to/input.dbc", "path/to/output.rs").with_options(options);
/// ```
#[derive(clap::Parser, Debug)]
pub struct Arguments {
    /// A file to read or `-` for stdin.
    #[arg(long)]
    input: InputArg,

    /// A file to write or `-` for stdout.
    #[arg(long)]
    output: OutputArg,

    #[command(flatten)]
    options: OptionsArguments,
}

impl Arguments {
    /// Builds a new instance of [`Arguments`].
    pub fn new(input: impl Into<InputArg>, output: impl Into<OutputArg>) -> Self {
        Self {
            input: input.into(),
            output: output.into(),
            options: Default::default(),
        }
    }

    /// Returns the arguments with the given options.
    pub fn with_options(self, options: OptionsArguments) -> Self {
        Self { options, ..self }
    }

    /// Performs the code generation taking this as the configuration arguments.
    pub fn run(self) -> anyhow::Result<()> {
        let Self {
            input,
            output,
            options,
        } = self;

        let args = Vec::from_iter(
            ["cargo", "veecle-os-cli"]
                .into_iter()
                .map(String::from)
                .chain(std::env::args().skip(1)),
        );
        let command = shlex::try_join(args.iter().map(|s| s.as_str()))?;

        let input_name = format!("{input:#}");
        let input_content = input.read_to_string()?;
        let code = Generator::new(&input_name, options.into(), &input_content).try_into_string()?;

        output.write(format!("// generated by `{command}`\n{code}"))?;

        Ok(())
    }
}

impl From<OptionsArguments> for veecle_os_data_support_can_codegen::Options {
    fn from(args: OptionsArguments) -> Self {
        Self {
            veecle_os_runtime: args.veecle_os_runtime.into_inner().parse(),
            veecle_os_data_support_can: args.veecle_os_data_support_can.into_inner().parse(),
            arbitrary: args.arbitrary.into(),
            serde: args.serde.into_inner().parse(),
            message_frame_validations: if args.validate_message_frames {
                Box::new(|message_name| Some(syn::parse_quote!(#message_name::validate_frame)))
            } else {
                Box::new(|_| None)
            },
        }
    }
}

impl From<ArbitraryOptionsArguments>
    for Option<veecle_os_data_support_can_codegen::ArbitraryOptions>
{
    fn from(args: ArbitraryOptionsArguments) -> Self {
        args.enabled
            .then(|| veecle_os_data_support_can_codegen::ArbitraryOptions {
                path: args.path.into_inner().parse(),
                cfg: args
                    .cfg
                    .as_ref()
                    .map(|arbitrary_cfg| Syn::parse(&arbitrary_cfg.0)),
            })
    }
}

#[cfg(test)]
mod tests {
    use super::Arguments;

    #[test]
    fn new_arguments_should_not_fail() {
        Arguments::new("/hello/world", "/hello/world");
    }
}
